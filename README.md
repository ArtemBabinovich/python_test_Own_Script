# Фонарь (тестовое задание)

Реализация фонаря должна удовлетворять следующим требованиям:
1. При запуске фонарь должен запрашивать хост:порт (по умолчанию
127.0.0.1:9999), подсоединяться по TCP и после этого начать
отрабатывать протокол управления.
2. При получении данных от сервера фонарь проверяет команду,
и, если она известна, обрабатывает команду, иначе молча ее игнорирует.
3. При получении команды ON фонарь включается (отрисовку
фонаря оставляем на ваше усмотрение).
4. При получении команды OFF фонарь выключается.
5. При получении команды COLOR фонарь меняет цвет.
6. При завершении работы фонарь корректно закрывает соединение
с сервером.
7. Реализация фонаря позволяет легко добавлять любые новые команды.


**Реализован:**
1. Версия `Python - 3.10`
2. Реализация сетевого протокола с помощью библиотеки `aiohttp`

**Для запуска:**
1. Скопируйте репозиторий.
2. Убедитесь что у вас установленна актуальная версия Python
3. Установите виртуальное окружение.
4. Установите необходимые зависимости из requirements.txt
 команда `pip install -r requirements.txt `
5. Перейдите в каталог _my_lamp_, где находится файл с кодом
6. В командной строке наберите команду `python lamp.py`
7. Если сервер работает, программа будет ожидать команды иначе выведет ошибку.


**Описание модуля:**

Модуль содержит класс `Lamp`

Класс `Lamp` представляет собой реализацию управляемого по сети фонаря, 
который работает по протоколу ПУФ (Протокол Управления Фонарем) через соединение TCP. 
Класс содержит следующие функции:

* `__init__(self, host='127.0.0.1', port=9999)`: 
это конструктор класса, который принимает два необязательных аргумента:
- `host` - строку с адресом сервера, по умолчанию равен 127.0.0.1;
- `port` - целое число с портом сервера, по умолчанию равен 9999;
- `_is_on` - логическое значение, указывающее, включена ли лампа;
- `color` - строку с цветом фонаря, по умолчанию равен white;
- `_supported_commands` - словарь, содержащий поддерживаемые команды, которые может обработать лампа;

* `async def handle_command(self, command)`: 
это асинхронная функция, которая принимает на вход строку `command` 
с командой в формате JSON и обрабатывает ее. Если строка не является корректным JSON,
то функция выводит предупреждение в лог и прекращает выполнение. Если в JSON нет поля `command`,
то функция выводит предупреждение в лог и прекращает выполнение. Если значение `command` не содержится
в словаре `_supported_commands`, то функция выводит предупреждение в лог и прекращает выполнение. 
Иначе вызывается соответствующая функция для обработки команды из словаря `_supported_commands`.


* `async def turn_on(self, metadata)`: 
это асинхронная функция, которая принимает на вход словарь `metadata` с метаданными команды `ON` (включение лампы). 
Функция устанавливает переменную `_is_on` в значение `True` и выводит сообщение в лог об успешном включении лампы.


* `sync def turn_off(self, metadata)`: 
это асинхронная функция, которая принимает на вход словарь `metadata` с метаданными команды `OFF` (выключение лампы).
Функция устанавливает переменную `_is_on` в значение `False` и выводит сообщение в лог об успешном выключении лампы.


* `async def change_color(self, metadata)`: 
это асинхронная функция, которая принимает на вход словарь `metadata` с метаданными команды `COLOR` (смена цвета лампы).
Если в метаданных передан цвет, то функция устанавливает переменную `_color` в соответствующее значение и
выводит сообщение в лог об успешной смене цвета. Если цвет не передан, то функция выводит предупреждение в
лог и прекращает выполнение


* `async def run(self)`:
запускается при запуске приложения и отвечает за основной цикл приложения.
В начале функции создается объект `ClientSession` из библиотеки `aiohttp`, который позволяет устанавливать соединение
с веб-сервером.
Далее формируется `URL`, по которому будет осуществляться подключение к веб-сокету, в данном случае `URL` 
имеет вид `http://<self._host>:<self._port>`.
Затем устанавливается соединение с веб-сокетом с помощью метода `ws_connect()`. После этого в цикле `async for`
обрабатываются входящие сообщения.
Если полученное сообщение является текстовым, то вызывается метод `handle_command`, который парсит JSON-объект команды,
определяет тип команды и передает управление соответствующему методу (`turn_on()`, `turn_off()` или `change_color()`).
Если полученное сообщение не является текстовым, то обрабатывается соответствующим образом, выводится сообщение об 
ошибке и цикл `async for` завершается.
Функция `run()` заканчивает свою работу, когда соединение с сервером закрывается или происходит ошибка во 
время работы соединения.


## **Тестовое задание по базам данных**
1. Перейдите в папку с названием `db`
2. Откройте файл с названием `test_design_db`